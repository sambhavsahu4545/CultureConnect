// Booking routes - handle all booking-related operations
// Create bookings, get bookings, cancel bookings, update payment status

import express from 'express';
import { body, validationResult } from 'express-validator';
import Booking from '../models/Booking.js';
import Notification from '../models/Notification.js';
import { protect } from '../middleware/auth.js';

const router = express.Router();

// Create a new booking
// POST /api/bookings
// User must be logged in to create a booking
router.post(
    '/',
    protect,
    [
        body('type').isIn(['flight', 'hotel', 'train', 'car-rental', 'tour-package', 'cruise'])
            .withMessage('Invalid booking type'),
        body('bookingDetails').notEmpty().withMessage('Booking details are required'),
        body('pricing.basePrice').isNumeric().withMessage('Base price must be a number'),
        body('pricing.totalPrice').isNumeric().withMessage('Total price must be a number'),
    ],
    async (req, res) => {
        try {
            // Validate input
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    success: false,
                    message: 'Validation failed',
                    errors: errors.array(),
                });
            }

            const { type, bookingDetails, pricing, payment, notes } = req.body;

            // Create the booking in the database
            // Booking reference number will be auto-generated by the model
            const booking = await Booking.create({
                user: req.user._id, // Link booking to the logged-in user
                type,
                bookingDetails,
                pricing: {
                    basePrice: pricing.basePrice,
                    taxes: pricing.taxes || 0,
                    fees: pricing.fees || 0,
                    discount: pricing.discount || 0,
                    totalPrice: pricing.totalPrice,
                    currency: pricing.currency || 'INR',
                },
                payment: payment || {
                    status: 'pending', // Payment not done yet
                },
                notes: notes || '',
                status: 'pending', // Booking starts as pending
            });

            // Send a notification to the user about their new booking
            await Notification.createNotification(req.user._id, {
                type: 'booking-confirmation',
                title: 'Booking Confirmed',
                message: `Your ${type} booking has been created. Reference: ${booking.bookingReference}`,
                data: {
                    bookingId: booking._id,
                    bookingReference: booking.bookingReference,
                },
                booking: booking._id,
                actionUrl: `/bookings/${booking._id}`, // User can click to view booking
                priority: 'high',
            });

            res.status(201).json({
                success: true,
                message: 'Booking created successfully',
                booking,
            });
        } catch (error) {
            console.error('Create booking error:', error);
            res.status(500).json({
                success: false,
                message: 'Server error',
                error: error.message,
            });
        }
    }
);

// Get all bookings for the logged-in user
// GET /api/bookings
// Can filter by type (flight, hotel, etc.) and status (pending, confirmed, etc.)
router.get('/', protect, async (req, res) => {
    try {
        const { type, status, page = 1, limit = 10 } = req.query;

        // Build query - only get bookings for this user
        const query = { user: req.user._id };
        if (type) query.type = type; // Filter by booking type if provided
        if (status) query.status = status; // Filter by status if provided

        // Calculate pagination (skip and limit)
        const skip = (parseInt(page) - 1) * parseInt(limit);

        // Get bookings from database, sorted by newest first
        const bookings = await Booking.find(query)
            .sort({ createdAt: -1 }) // Newest bookings first
            .skip(skip)
            .limit(parseInt(limit));

        // Count total bookings (for pagination info)
        const total = await Booking.countDocuments(query);

        res.json({
            success: true,
            bookings,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total,
                pages: Math.ceil(total / parseInt(limit)), // Total number of pages
            },
        });
    } catch (error) {
        console.error('Get bookings error:', error);
        res.status(500).json({
            success: false,
            message: 'Server error',
            error: error.message,
        });
    }
});

// Get a specific booking by ID
// GET /api/bookings/:id
// User can only get their own bookings (security check)
router.get('/:id', protect, async (req, res) => {
    try {
        // Find booking that belongs to this user
        const booking = await Booking.findOne({
            _id: req.params.id,
            user: req.user._id, // Make sure user can only see their own bookings
        });

        if (!booking) {
            return res.status(404).json({
                success: false,
                message: 'Booking not found',
            });
        }

        res.json({
            success: true,
            booking,
        });
    } catch (error) {
        console.error('Get booking error:', error);
        res.status(500).json({
            success: false,
            message: 'Server error',
            error: error.message,
        });
    }
});

// Cancel a booking
// PUT /api/bookings/:id/cancel
// User can cancel their own bookings (with some restrictions)
router.put(
    '/:id/cancel',
    protect,
    [
        body('reason').optional().isString(), // Optional cancellation reason
    ],
    async (req, res) => {
        try {
            const { reason } = req.body;

            // Find the booking (must belong to this user)
            const booking = await Booking.findOne({
                _id: req.params.id,
                user: req.user._id,
            });

            if (!booking) {
                return res.status(404).json({
                    success: false,
                    message: 'Booking not found',
                });
            }

            // Check if booking can be cancelled
            if (booking.status === 'cancelled') {
                return res.status(400).json({
                    success: false,
                    message: 'Booking is already cancelled',
                });
            }

            // Can't cancel a booking that's already completed
            if (booking.status === 'completed') {
                return res.status(400).json({
                    success: false,
                    message: 'Completed bookings cannot be cancelled',
                });
            }

            // Update booking to cancelled status
            booking.status = 'cancelled';
            booking.cancellation = {
                cancelledAt: new Date(),
                cancellationReason: reason || 'Cancelled by user',
                refundStatus: 'pending', // Refund will be processed later
            };

            // Calculate refund amount (if payment was made)
            // Simple logic: 80% refund for cancellations (can be made more sophisticated)
            if (booking.payment.status === 'completed') {
                booking.cancellation.refundAmount = booking.pricing.totalPrice * 0.8; // 80% refund
            }

            await booking.save();

            // Notify user about cancellation
            await Notification.createNotification(req.user._id, {
                type: 'booking-cancelled',
                title: 'Booking Cancelled',
                message: `Your booking ${booking.bookingReference} has been cancelled.`,
                data: {
                    bookingId: booking._id,
                    bookingReference: booking.bookingReference,
                    refundAmount: booking.cancellation.refundAmount,
                },
                booking: booking._id,
                priority: 'medium',
            });

            res.json({
                success: true,
                message: 'Booking cancelled successfully',
                booking,
            });
        } catch (error) {
            console.error('Cancel booking error:', error);
            res.status(500).json({
                success: false,
                message: 'Server error',
                error: error.message,
            });
        }
    }
);

// Update payment status for a booking
// PUT /api/bookings/:id/payment
// Used when payment gateway confirms payment or payment fails
router.put(
    '/:id/payment',
    protect,
    [
        body('status').isIn(['pending', 'completed', 'failed', 'refunded'])
            .withMessage('Invalid payment status'),
        body('method').optional().isIn(['credit-card', 'debit-card', 'upi', 'net-banking', 'wallet', 'cash']),
        body('transactionId').optional().isString(), // Payment gateway transaction ID
    ],
    async (req, res) => {
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    success: false,
                    message: 'Validation failed',
                    errors: errors.array(),
                });
            }

            const { status, method, transactionId } = req.body;

            // Find the booking
            const booking = await Booking.findOne({
                _id: req.params.id,
                user: req.user._id,
            });

            if (!booking) {
                return res.status(404).json({
                    success: false,
                    message: 'Booking not found',
                });
            }

            // Update payment information
            booking.payment.status = status;
            if (method) booking.payment.method = method;
            if (transactionId) booking.payment.transactionId = transactionId;
            
            // If payment is completed, mark booking as confirmed and record payment time
            if (status === 'completed') {
                booking.payment.paidAt = new Date();
                booking.status = 'confirmed'; // Booking is now confirmed
            }

            await booking.save();

            // Send notification about payment status
            const notificationType = status === 'completed' ? 'payment-success' : 'payment-failed';
            await Notification.createNotification(req.user._id, {
                type: notificationType,
                title: status === 'completed' ? 'Payment Successful' : 'Payment Failed',
                message: `Payment ${status} for booking ${booking.bookingReference}`,
                data: {
                    bookingId: booking._id,
                    bookingReference: booking.bookingReference,
                    transactionId,
                },
                booking: booking._id,
                priority: 'high', // Payment notifications are important
            });

            res.json({
                success: true,
                message: 'Payment status updated successfully',
                booking,
            });
        } catch (error) {
            console.error('Update payment error:', error);
            res.status(500).json({
                success: false,
                message: 'Server error',
                error: error.message,
            });
        }
    }
);

export default router;

